\documentclass[a4paper,10pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}
\usepackage{listings}
\usepackage{fullpage}

\begin{document}
\lstset{language=Haskell} 
\setcounter{secnumdepth}{0}
\title{План лекций}
\date{}
\maketitle

\section{Введение}
Компилятор ghc, ghci, Haskell Platform.

Haskell – чисто функциональный, типизированный язык программирования.

Чистые функции.

Типы Int, Integrer, Float, Double, Bool = True | False, Char.

Арифметические операции.
\begin{lstlisting}
+, -, *, /, div, mod
\end{lstlisting}

Тип функции:
\begin{lstlisting}
and :: Bool -> Bool -> Bool
and False _ = False
and True x = x
\end{lstlisting}

Кортежи (a,b).
fst, snd.

Списки
\begin{lstlisting}
[a] = [] | a : [a]
[]
1:2:[]
[1,2]
[1..3] = [1,2,3]
[1,1.5..3] = [1.0,1.5,2.0,2.5,3.0]
\end{lstlisting}

Конструктор списков (list comprehensions)
\begin{lstlisting}
[x | x <- [1..3]] = [1,2,3]
[(x,y) | x <- [1,2], y <- [1,2]] = [(1,1), (1,2), (2,1), (2,2)]
[(x,y) | x <- [1..3], y <- [1..4], x == y] = [(1,1), (2,2), (3,3)]
\end{lstlisting}

\section{Базовые функции со списками}
\begin{lstlisting}
head :: [a] -> [a]
head (x:xs) = x
tail :: [a] -> [a]
tail (x:xs) = xs

(++) :: [a] -> [a] -> [a]
(++) [] ys     = ys
(++) (x:xs) ys = x : (xs ++ ys)

(x:_)  !! 0 = x
(_:xs) !! n = xs !! (n-1)

reverse :: [a] -> [a]
reverse [] = []
reverse (x:xs) = reverse xs ++ [x]

reverse l =  rev l [] where
    rev []     a = a
    rev (x:xs) a = rev xs (x:a)

take :: Int -> [a] -> [a]
take _ []     = []
take n (x:xs) | n <= 0    = []
              | otherwise = x : take (n-1) xs

drop

\end{lstlisting}

\section{Бесконечные списки}
\begin{lstlisting}
[1..]

[2,4..]

take 5 [1..]
[1,2,3,4,5]

repeat :: a -> [a]
repeat x = x : repeat x

take 2 (repeat 3)
[3,3]

take 2 (3 : repeat 3)
3 : take 1 (repeat 3)
3 : take 1 (3 : repeat 3)
3 : 3 : take 0 (repeat 3)
3 : 3 : take 0 (3 : repeat 3)
3 : 3 : [] = [3,3]

$
($) :: (a -> b) -> a -> b
f $ x = f x

replicate :: Int a -> [a]
replicate n x = take n $ repeat x

cycle :: [a] -> [a]
cycle xs = xs ++ cycle xs

take 5 $ cycle [1,2]
[1,2,1,2,1]

iterate :: (a -> a) -> a -> [a]
iterate f x = x : iterate f (f x)
\end{lstlisting}

Линейный генератор 
\begin{lstlisting}
f x = mod (5*x + 3) 11
take 5 $ iterate f 1
[1,8,10,9,4]
\end{lstlisting}

\section{Функции высших порядков}

\begin{lstlisting}
takeWhile :: (a -> Bool) -> [a] -> [a]
takeWhile _ []     = []
takeWhile p (x:xs) | p x       = x : takeWhile p xs
                   | otherwise = []

dropWhile

filter :: (a -> Bool) -> [a] -> [a]
filter _ [] = []
filter p (x:xs) = if p x then x : filter xs else filter xs
\end{lstlisting}

Решето Эратосфена

\begin{lstlisting}
sieve :: [Integrer] -> [Integrer]
sieve (x:xs) = x : sieve (filter (\y -> y `mod` x /= 0) xs)

primes = sieve [2..]
\end{lstlisting}

Map и zipWith

\begin{lstlisting}
map :: (a -> b) -> a -> b
map f []     = []
map f (x:xs) = f x : map f xs

map (^2) [1..5]
[1,4,9,16,25]

map (2^) [1..5]
[2,4,8,16,32]

zipWith :: (a -> b -> c) -> [a] -> [b] -> [c]
zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys
zipWith _ _ _           = []

fibs = 0:1:zipWith (+) fibs (tail fibs)

fib n = fibs !! n

(!!) :: Int -> [a] -> [a]
(x:xs) !! 0 = x
(x:xs) !! n = xs !! (n-1)

fib 3
2

fibs !! 3
(0:1:zipWith (+) fibs (tail fibs)) !! 3
(1:zipWith (+) fibs (tail fibs)) !! 2
(zipWith (+) fibs (tail fibs)) !! 1
(0 + 1 : zipWith (+)
    (1:zipWith (+) fibs (tail fibs))
    (zipWith (+) fibs (tail fibs))) !! 1
(zipWith (+)
    (1:zipWith (+) fibs (tail fibs))
    (zipWith (+) fibs (tail fibs))) !! 0
(zipWith (+)
    (1:zipWith (+) fibs (tail fibs))
    (zipWith (+)
        (0:1:zipWith (+) fibs (tail fibs))
        (1:zipWith (+) fibs (tail fibs)))) !! 0
(zipWith (+)
    (1:zipWith (+) fibs (tail fibs))
    (0 + 1 : zipWith (+)
        (1:zipWith (+) fibs (tail fibs))
        (zipWith (+) fibs (tail fibs)))) !! 0
(1 + 1 : zipWith (+)
    (zipWith (+) fibs (tail fibs))
    (zipWith (+)
        (1:zipWith (+) fibs (tail fibs))
        (zipWith (+) fibs (tail fibs)))) !! 0
2


\end{lstlisting}

\section{Свёртка}

\begin{lstlisting}
sum []     = 0
sum (x:xs) = x + sum xs

concat []       = []
concat (xs:xss) = xs ++ concat xss

foldr :: (a -> b -> b) -> b -> [a] -> b
foldr f e []     = e
foldr f e (x:xs) = f x foldr f e xs

sum = foldr (+) 0
concat = foldr (++) []

foldl :: (b -> a -> b) -> b -> [a] -> b
foldl f e []     = e
foldl f e (x:xs) = foldl f (f e x) xs

reverse = foldl (flip (:)) []

flip :: (a -> b -> c) -> b -> a -> c
flip f x y = f y x

foldr1 :: (a -> a -> a) -> [a] -> a
foldr1 f [x]    = x
foldr1 f (x:xs) = f x foldr1 f xs

maximum = foldr1 max

\end{lstlisting}
\end{document}
